/*
    Cantor programming language core

    Copyright Â© 2014 Vladislav Javadov (aka Freeman)
*/

public class with inner of
  class ByteArray[Word scale] of
    static granularity = const 8;
    if scale <= granularity then
      public out Core:Byte RawByte;
      public RawByte[Core:Byte];
    else
      public final class Bytes = 0..[scale +/ granularity]--;
      public out Core:Byte RawBytes[Bytes];
      public RawBytes[Core:Byte; Bytes];
    end;
  end;

  class ShortWordArray[Word scale] of
    static granularity = const 16;
    if scale <= granularity then
      public out Core:ShortWord RawShortWord;
      public RawShortWord[Core:ShortWord];
    else
      public final class ShortWords = 0..[scale +/ granularity]--;
      public out Core:ShortWord RawShortWords[ShortWords];
      public RawShortWords[ShortWords; Core:ShortWord];
    end;
  end;

  class LongWordArray[Word scale] of
    static granularity = const 32;
    if scale <= granularity then
      public out Core:LongWord RawLongWord;
      public RawLongWord[Core:LongWord];
    else
      public final class LongWords = 0..[scale +/ granularity]--;
      public out Core:LongWord RawLongWords[LongWords];
      public RawLongWords[LongWords; Core:LongWord];
    end;
  end;

  class QuadWordArray[Word scale] of
    static granularity = const 64;
    if scale <= granularity then
      public out Core:QuadWord RawQuadWord;
      public RawQuadWord[Core:QuadWord];
    else
      public final class QuadWords = 0..[scale +\ granularity]--;
      public out Core:QuadWord RawQuadWords[QuadWords];
      public RawQuadWords[QuadWords; Core:QuadWord];
    end;
  end;

  class SingleFloatArray[Word scale] of
    static granularity = const 32;
    if scale <= granularity then
      public out Core:SingleFloat RawSingleFloat;
      public RawSingleFloat[Core:SingleFloat];
    else
      public inner class SingleFloats = 0..[scale +/ granularity]--;
      public out Core:SingleFloat RawSingleFloats[SingleFloats];
      public RawSingleFloats[SingleFloats; Core:SingleFloat];
    end;
  end;

  class DoubleFloatArray[Word scale] of
    static granularity = const 64;
    if scale <= granularity then
      public out Core:DoubleFloat RawDoubleFloat;
      public RawDoubleFloat[Core:DoubleFloat];
    else
      public final class DoubleFloats = 0..[scale +/ granularity]--;
      public out Core:DoubleFloat RawDoubleFloats[DoubleFloats];
      public RawDoubleFloats[DoubleFloats; Core:DoubleFloat];
    end;
  end;

  class Number[Word scale] from
    ByteArray[scale], ShortWordArray[scale], LongWordArray[scale], QuadWordArray[scale],
    SingleFloatArray[scale], DoubleFloatArray[scale]
  of
    public final class Nibble = Core:Word[scale \ 2];

    case Nibble
      when Core:Byte then
        public LowNibble = partial RawBytes[0];
        public HighNibble = partial RawBytes[1];
      when Core:ShortWord then
        public LowNibble = partial RawShortWords[0];
        public HighNibble = partial RawShortWords[1];
      when Core:LongWord then
        public LowNibble = partial RawLongWords[0];
        public HighNibble = partial RawLongWords[1];
      when Core:QuadWord then
        public LowNibble = partial RawQuadWords[0];
        public HighNibble = partial RawQuadWords[1];
    end;

    public out Core:Boolean AsBoolean;
    public AsBoolean[Core:Boolean];

    public out Core:Byte AsByte;
    public AsByte[Core:Byte];

    public out Core:ByteInt AsByteInt;
    public AsByteInt[Core:ByteInt];

    public out Core:ShortWord AsShortWord;
    public AsShortWord[Core:ShortWord];

    public out Core:ShortInt AsShortInt;
    public AsShortInt[Core:ShortInt];

    public out Core:LongWord AsLongWord;
    public AsLongWord[Core:LongWord];

    public out Core:LongInt AsLongInt;
    public AsLongInt[Core:LongInt];

    public out Core:QuadWord AsQuadWord;
    public AsQuadWord[Core:QuadWord];

    public out Core:QuadInt AsQuadInt;
    public AsQuadInt[Core:QuadInt];

    public out Core:SingleFloat AsSingleFloat;
    public out Core:DoubleFloat AsDoubleFloat;
    public out Core:ExtendedFloat AsExtendedFloat;
  end;

  class Any[Word scale] from Number[scale] of
    if scale <= 32 then
      public out Core:Character RawCharacter;
      public RawCharacter[Core:Character];
    end;
  end;

  class Integer[Word scale] = Number[scale];
  class Word[Word scale] = Any[scale];
  class Float[Word scale] = Number[scale];

  class Boolean = Number[1];
  class Character = Number[32];

  class ByteInt = Integer[8];
  class Byte = Word[8];

  class ShortInt = Integer[16];
  class ShortWord = Word[16];

  class LongInt = Integer[16];
  class LongWord = Word[16];

  class QuadInt = Integer[16];
  class QuadWord = Word[16];

  class SingleFloat = Float[32];
  class DoubleFloat = Float[64];
end;
